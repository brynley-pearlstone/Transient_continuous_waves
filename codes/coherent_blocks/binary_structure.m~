function [block_length, block_numbers, n_breaks,n_changepoints ] = binary_structure( binary_number )
% This function deconstructs the binary number and determined how many
% blocks, how many changepoints, and where each block begins and ends.

oldbits = circshift(binary_number, [0,1]);

clipped_binary = binary_number(1:end-2)
is_changepoint = abs(diff(clipped_binary));
n_changepoints = sum(is_changepoint);

block_end = (diff(clipped_binary)<0); %circshift((oldbits - binary_number==1), [0,-1]); % Compare where thhe number is not to where it used to be to determine if a block has ended
n_breaks = sum(block_end); % If there is a break, we add in the normalisation for the marginalisation over h

block_start = (diff(clipped_binary)>0); %(binary_number - oldbits==1);
if clipped_binary(end-1) == 0
    block_start = cat(2,  block_start, clipped_binary(end));
else
    block_start = cat(2,  block_start, abs(clipped_binary(end)-1));
end

if clipped(binary(1) ==1 && clipped(binary(2) == 0
     block_end = cat(2, block_end,1)
elseif 
if clipped_binary(end) == 1
   block_end = cat(2, block_end,1)
else
   block_end = cat(2, block_end, 0) 
end
   

block_number = ones(size(binary_number, 1), size(binary_number, 2));
n_blocks = sum(block_start);
block_length = zeros(1,n_blocks);
block = 1;
itt = 1;

while itt < length(binary_number)-3
    if block_start(itt) ==1
        count = 0;
        while block_end(itt+count) ==0 && itt + count <= length(block_end);
            count = count + 1;
        end
        block_length(block) = count + 1;
        block = block + 1;
    end
    block_number(itt+1) = block_number(itt) +  block_start(itt);
    itt = itt+1
end
block_numbers = block_number(2:end);
if isempty(block_length)
    block_length = 0;
end
end

